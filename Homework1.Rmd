---
title: "RBIF111 Homework 1"
author: "Rita Pecuch"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 1

Objective: Create a function that calculates the mean of a numeric vector starting from the first element to the last. Then compare this to the results of the mean() R function.

Function definition:

```{r mean function}
calculate_mean <- function(vector, na.rm=F){
  # Remove NA values if needed
  if (na.rm){
    vector <- vector[!is.na(vector)]
  }
  # Calculate sum of all observations
  total <- 0
  for(x in vector){
      total <- total + x
  }
  
  # Divide total by number of observations
  mean <- total / length(vector)
  return(mean)
}
```

Comparing function results with mean() R function:

```{r comparing mean functions}
test_vector <- c(1,2,3,4,5,6,7,11,100)
# R function
mean(test_vector)
# Custom function
calculate_mean(test_vector)

# Add NA value
test_vector_na <- c(test_vector, NA)
mean(test_vector_na)
calculate_mean(test_vector_na)

# Add NA value and use na.rm=T
mean(test_vector_na, na.rm=T)
calculate_mean(test_vector_na, na.rm=T)
```

## Question 2

Objective A: Execute and explain the results of the following block of R code:

```{r}
mat <- matrix(1:9, nrow = 3, ncol = 3)
```
This line of code uses the matrix() function to generate a matrix with numerical data values 1-9. The matrix has 3 rows and 3 columns, and the data values fill in the first column, then the second, then the third. There is no need for recycling because the number of data values equals the dimensions of the matrix. Because the result of the matrix() function is being stored in a variable, nothing is printed.

```{r}
which.max(mat)
```
This line of code uses the which.max() function to determine the index of the first instance of the maximum of the matrix, which is index 9. The index is determined by column, meaning looking through all the values in column 1 top to bottom, then column 2, then column 3. The result is not being stored in a variable and thus is printed.

```
which.max(as.data.frame(mat))
```
This line of code attempts to use the which.max() function on the matrix that has been coerced to a data frame. An error message is printed because the which.max() function takes a single vector as an input. In R, a matrix is stored internally as single vector, but a data frame is stored in a way that rather each column is a vector.

```
mat[1:9,]
```
This line of code attempts to subset a matrix, but an error message is printed because the first argument is specifying rows 1-9. This matrix only has rows 1-3, as it is a 3 x 3 dimension matrix.

```
mat[,1:9]
```
This line of code attempts to subset a matrix, but an error message is printed because the second argument is specifying columns 1-9. This matrix only has columns 1-3, as it is a 3 x 3 dimension matrix.


Objective B: Execute and explain the results of the following block of R code:

```{r}
m <- matrix(c(1:5,NA,7,7,NA), nrow=3,ncol=3,byrow=T); print(m)
```
This line of code uses the matrix() function to generate a matrix with the following values: 1, 2, 3, 4, 5, NA, 7, 7, and NA. The matrix has 3 rows and 3 columns, and because byrow=T is specified the data values fill in the first row, then the second, then the third. There is no need for recycling because the number of data values equals the dimensions of the matrix. Nothing is printed when the result of a function is being stored in a variable, but the print() function is then called which prints the matrix.

```{r}
numbers <- NULL
```
This line of code assigns the value NULL to the variable called numbers. Nothing is printed because the value is being stored in a variable. When used with the below chunk of code, this line of code serves the purpose of initializing the numbers variable with an empty value.

```
for(i in 1:4){
  temp <- m[i,]
  numbers <- c(numbers, temp)
}
```
This block of code attempts to loop through the numbers in the range 1-4 and apply the following logic at each iteration:
- Subset a single row from matrix m with the row number matching the current iteration of the loop
- Add all of the values in the subsetted matrix (a vector) to the current values of the numbers variable.
However, an error message is printed on the final iteration of the loop because matrix m is a 3 x 3 matrix and does not have a row 4. Because the loop was able to successfully complete iterations 1-3, the current value of the numbers variable is c(1, 2, 3, 4, 5, NA, 7, 7, NA).

## Question 3

Objective: Select a dataset from GEO, download it using the GEO2R code, and analyze it.

Chosen dataset: Comparison of Gene Expression in Uterine Smooth Muscle Tumors

Experiment type: Expression profiling by array

GSEXXX number: GSE764

gplXXX number: GPL80

Control group: myomtrium samples

Treatment group: uterine leiomyosarcoma samples

TODO: remove execution of this in report
Code to get plate annotation info:

```{r get PlatAnnotInfo}
library(GEOquery)
library(data.table)
library(org.Hs.eg.db)
z <- getGEO("GPL80")
PlateAnnotInfo <- as.data.table(z@dataTable@table)
PlateAnnotInfo <- PlateAnnotInfo[,c("ID", "Gene Symbol", "ENTREZ_GENE_ID"), with = FALSE]
PlateAnnotInfo$`Gene Symbol` <- gsub(" ///.+", "", PlateAnnotInfo$`Gene Symbol`)
PlateAnnotInfo$ENTREZ_GENE_ID <- gsub(" ///.+", "", PlateAnnotInfo$ENTREZ_GENE_ID)
PlateAnnotInfo <- PlateAnnotInfo[!PlateAnnotInfo$`Gene Symbol` == "",]
setnames(PlateAnnotInfo, c("Gene Symbol", "ENTREZ_GENE_ID"), c("SYMBOL", "ENTREZID"))
PlateAnnotInfo <- PlateAnnotInfo[!is.na(ENTREZID),]
PlateAnnotInfo <- PlateAnnotInfo[!ENTREZID == "",]
PlateAnnotInfo$ENTREZID <- as.character(PlateAnnotInfo$ENTREZID)
mappings <- AnnotationDbi::select(org.Hs.eg.db, keys=PlateAnnotInfo$ENTREZID, columns=c("GENENAME"),keytype="ENTREZID")
PlateAnnotInfo <- unique(merge(PlateAnnotInfo, mappings, by = "ENTREZID", allow.cartesian = TRUE))
PlateAnnotInfo <- PlateAnnotInfo[,c("ID", "ENTREZID", "SYMBOL", "GENENAME")]
PlateAnnotInfo$GPLID <- "GPL80"
# datatable(head(as.data.frame(PlateAnnotInfo),10), filter = 'top', options = list(pageLength = 10, scrollX = TRUE, scrollY = "400px", autoWidth = TRUE))
```

TODO: remove execution of this in report
Code to download data and save to working directory:

```{r download}
library(DESeq2)
library(limma)
library(data.table)

# Define download function
GEODataDownload <- function(DS, gpl, gsm, PlateAnnotInfo, GenerateMetaData, Technology){
  library(DESeq2); library(limma)
  if(Technology == "Array"){
    gset <- getGEO(DS)
    if(length(gset) > 1) idx <- grep(gpl, attr(gset, "names")) else idx <- 1
    gset <- gset[[idx]]
    fvarLabels(gset) <- make.names(fvarLabels(gset))
    comp <- gsub(" ", "", gsm)
    comp <- gsub(",", "", comp)
    gsms <- paste0(comp)
    #### Set up raw names ####
    sml <- c()
    for(i in 1:nchar(gsms)){ sml[i] <- substr(gsms,i,i)}
    ex <- exprs(gset)
    qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
    LogC <- (qx[5] > 100) ||
      (qx[6]-qx[1] > 50 && qx[2] > 0) ||
      (qx[2] > 0 && qx[2] < 1 && qx[4] < 2)
    if(LogC){ ex[which(ex <= 0)] <- NaN
    exprs(gset) <- log2(ex) }
    sml <- paste("G", sml, sep="")
    f1 <- as.factor(sml)
    gset$description2 <- f1
    design <- model.matrix(~description2 + 0, gset)
    colnames(design) <- levels(f1)
    fit <- lmFit(gset, design)
    cont.matrix <- makeContrasts(G1-G0, levels = design)
    fit2 <- contrasts.fit(fit, cont.matrix)
    fit2 <- eBayes(fit2, 0.01)
    tT <- topTable(fit2, adjust="fdr", sort.by = "B", number = 25000000000)
    #### subset ####
    ex2 <- data.table(subset(tT, select=c("ID", "logFC", "P.Value", "adj.P.Val")))
    ex2$ID <- as.character(ex2$ID)
    #### annotate with gene names ####
    plat <- PlateAnnotInfo[GPLID == gpl,][,!"GPLID", with = FALSE]
    if(nrow(plat) == 0){ print(paste("There is no annotation information available for", gpl)) }
    plat$ID <- as.character(plat$ID)
    plat <- plat[!duplicated(plat$ID),]
    ex2 <- merge(plat, ex2, by = "ID")
    ex2$ID <- as.character(ex2$ID)
    exraw <- data.table(ex)
    exraw$ID <- as.character(rownames(ex))
    #### annotate raw data with gene names ####
    ex2 <- merge(ex2, exraw, by = "ID")
    #### Generate Meta Data ####
    Pdat <- pData(gset)
    #### Add Meta data ####
    Pdat <- as.data.table(Pdat)
    return(list(Data = ex2, MetaData = Pdat))
  }
  
  if(Technology == "RNAseq"){
    ACC <- paste("acc=", DS, sep = "")
    file <- paste("file=", DS, "_raw_counts_GRCh38.p13_NCBI.tsv.gz", sep = "")
    comp <- gsub(" ", "", gsm)
    comp <- gsub(",", "", comp)
    gsms <- paste0(comp)
    #### Set up DEG names ####
    urld <- "https://www.ncbi.nlm.nih.gov/geo/download/?format=file&type=rnaseq_counts"
    path <- paste(urld, ACC, file, sep="&");
    tbl <- as.matrix(data.table::fread(path, header=T, colClasses="integer"), rownames="GeneID")
    exraw <- tbl 
    apath <- paste(urld, "type=rnaseq_counts", "file=Human.GRCh38.p13.annot.tsv.gz", sep="&")
    annot <- data.table::fread(apath, header=T, quote="", stringsAsFactors=F, data.table=F)
    rownames(annot) <- annot$GeneID
    sml <- strsplit(gsms, split="")[[1]]
    sel <- which(sml != "X")
    sml <- sml[sel]
    tbl <- tbl[ ,sel]
    gs <- factor(sml)
    groups <- make.names(c("Ctrl", "Tx"))
    levels(gs) <- groups
    sample_info <- data.frame(Group = gs, row.names = colnames(tbl))
    keep <- rowSums( tbl >= 10 ) >= min(table(gs))
    tbl <- tbl[keep, ]
    ds <- DESeqDataSetFromMatrix(countData=tbl, colData=sample_info, design= ~Group)
    ds <- DESeq(ds, test="Wald", sfType="poscount")
    r <- results(ds, contrast=c("Group", groups[2], groups[1]), alpha=0.05, pAdjustMethod ="fdr")
    tT <- r[order(r$padj)[1:length(r$padj)],]
    tT <- merge(as.data.frame(tT), annot, by=0, sort=F)
    tT <- subset(tT, select=c("GeneID","padj","pvalue","lfcSE","stat","log2FoldChange","baseMean","Symbol","Description"))
    #### subset ####
    ex2 <- data.table(subset(tT, select=c("GeneID", "Symbol", "Description", "log2FoldChange", "pvalue", "padj")))
    #### Adjust column names ####
    setnames(ex2, c("GeneID", "Symbol", "Description"), c("ENTREZID", "SYMBOL", "GENENAME"))
    #### Get Raw data ####
    GeneID <- as.integer(rownames(exraw))
    exraw <- as.data.table(exraw)
    #### Update column names ####
    exraw$ENTREZID <- GeneID
    #### merge FC and raw data together ####
    mer <- merge(ex2, exraw, by = "ENTREZID")
    return(mer)
  }
}

# Execute download function
ArrayData <- GEODataDownload(DS = "GSE764", gpl = "GPL80", gsm = "00001XXXXXXX11111111XXXXXX", PlateAnnotInfo = PlateAnnotInfo, Technology = "Array")
# Preview data
head(as.data.frame(ArrayData[["Data"]]),10)
# Save to working directory
path_to_write <- paste0(getwd(), "/ArrayData.txt")
write.table(as.data.frame(ArrayData[["Data"]]), file=path_to_write, sep="\t")
```

TODO: remove execution of this part
Code to reload data file and perform manipulations/calculations:

```{r manipulate}
# Read data
array_data <- read.table(path_to_write, sep="\t")
# Get preview of data
head(as.data.frame(array_data),10)
```

TODO: make sure to go back and do part c

Code to create avg. sample gene expression charts:

```{r plot}
# control samples: GSM11625, GSM11757, GSM11758, GSM11759
# treatment samples: GSM11760, GSM11768, GSM11769, GSM11770, GSM11771, GSM11772, GSM11773, GSM11774, GSM11775
library(stringr)
# Get all sample names
sample_cols <- names(array_data)[grep("^GSM", names(array_data))]
# Get avg for each sample
avgs <- c()
for(col in sample_cols){
  avg <- mean(array_data[[col]], na.rm=T)
  avgs <- c(avgs, avg)
}
names(avgs) <- sample_cols

# TODO: see if these charts need to have control and treatment groups split
# Plots
hist(avgs)
boxplot(avgs)
stripchart(avgs, method="stack")
dotchart(avgs)
dotchart(sort(avgs))

```

Code to create avg. gene expression per gene charts:

```{r plot gene}
# Get avg. for each gene
array_data$AVG_EXPRESSION <- rowMeans(array_data[, 8:length(array_data)], na.rm=T)

# TODO: see if these charts need gene names
# Plots
hist(array_data$AVG_EXPRESSION)
boxplot(array_data$AVG_EXPRESSION)
dotchart(sort(array_data$AVG_EXPRESSION))

```

Code to find genes with the highest and the lowest expression levels across all samples – capture their names and characteristic expression levels.

TODO: the rest of question 3

## Question 4

Objective: For all of the columns in the UCI machine learning data set, calculate the number of missing values, the mean, median, standard deviation. For categorical variables, calculate the counts for each feature. Visualize these results as boxplots. Describe any findings and why the calculated values may be different between each column.

Dataset: Heart Disease, Cleveland database

Code to read dataset into R:

```{r ml data read}
setwd("/Users/ritapecuch/Downloads/heart+disease")
# Read dataset
ml_data_path <- paste0(getwd(), "/processed.cleveland.data")
ml_col_names <- c("age", "sex", "cp", "trestbps", "chol", "fbs", "restecg", "thalach", "exang", "oldpeak", "slope", "ca", "thal", "num")
ml_data <- read.table(ml_data_path, sep=",", col.names = ml_col_names)
```

Calculations and plots:

```{r ml data}
na_counts <-  colSums(is.na(ml_data))
categorical_vars <- c("sex", "cp", "fbs", "restecg", "exang", "slope", "thal")

# Get stats for each column
for (col in names(ml_data)){
  print(col)
  num_missing <- na_counts[[col]]
  mean <- mean(ml_data[[col]], na.rm=T)
  median <- median(ml_data[[col]], na.rm=T)
  sd <- sd(ml_data[[col]], na.rm=T)
  
  if (col %in% categorical_vars){
    category_counts <- table(ml_data[[col]])
    print(category_counts)
  }
}
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
